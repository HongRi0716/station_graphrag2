# æ™ºèƒ½ä½“è®¾è®¡é€»è¾‘æ·±åº¦åˆ†æ

> **å‚è€ƒå¯¹è±¡**: å›¾è°±ä¸“å®¶ (ArchivistAgent)  
> **åˆ†ææ—¶é—´**: 2025-11-27  
> **åˆ†æç›®æ ‡**: æ·±å…¥å‰–ææ™ºèƒ½ä½“ç³»ç»Ÿçš„è®¾è®¡å“²å­¦ã€æ¶æ„æ¨¡å¼å’Œå®ç°æ€è·¯

---

## ğŸ“‹ ç›®å½•

1. [æ ¸å¿ƒè®¾è®¡å“²å­¦](#æ ¸å¿ƒè®¾è®¡å“²å­¦)
2. [æ¶æ„åˆ†å±‚è®¾è®¡](#æ¶æ„åˆ†å±‚è®¾è®¡)
3. [å›¾è°±ä¸“å®¶æ·±åº¦å‰–æ](#å›¾è°±ä¸“å®¶æ·±åº¦å‰–æ)
4. [é€šç”¨è®¾è®¡æ¨¡å¼](#é€šç”¨è®¾è®¡æ¨¡å¼)
5. [æ™ºèƒ½ä½“åä½œæœºåˆ¶](#æ™ºèƒ½ä½“åä½œæœºåˆ¶)
6. [æ€ç»´é“¾å¯è§†åŒ–](#æ€ç»´é“¾å¯è§†åŒ–)
7. [å·¥å…·è°ƒç”¨æ¶æ„](#å·¥å…·è°ƒç”¨æ¶æ„)
8. [è®¾è®¡äº®ç‚¹ä¸åˆ›æ–°](#è®¾è®¡äº®ç‚¹ä¸åˆ›æ–°)

---

## æ ¸å¿ƒè®¾è®¡å“²å­¦

### 1. é¢†åŸŸä¸“å®¶åŒ– (Domain Specialization)

**è®¾è®¡ç†å¿µ**: æ¯ä¸ªæ™ºèƒ½ä½“éƒ½æ˜¯ç‰¹å®šé¢†åŸŸçš„ä¸“å®¶ï¼Œè€Œéé€šç”¨åŠ©æ‰‹

```
ä¼ ç»ŸAIåŠ©æ‰‹:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  é€šç”¨AIåŠ©æ‰‹      â”‚
  â”‚  (ä»€ä¹ˆéƒ½èƒ½åš)    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
  èƒ½åŠ›åˆ†æ•£ã€ä¸“ä¸šæ€§ä¸è¶³

æœ¬ç³»ç»Ÿè®¾è®¡:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ å›¾è°±ä¸“å®¶     â”‚  â”‚ æ“ä½œç¥¨ä¸“å®¶   â”‚  â”‚ äº‹æ•…é¢„æƒ³ä¸“å®¶ â”‚
  â”‚ (æ£€ç´¢ä¸“ç²¾)   â”‚  â”‚ (æ“ä½œä¸“ç²¾)   â”‚  â”‚ (æ¨æ¼”ä¸“ç²¾)   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“              â†“              â†“
  å„å¸å…¶èŒã€ä¸“ä¸šæ·±åº¦å¼º
```

**å®ç°ä½“ç°**:
- **å›¾è°±ä¸“å®¶ (Archivist)**: ä¸“æ³¨äºçŸ¥è¯†æ£€ç´¢ã€å›¾è°±éå†ã€å†å²æ•°æ®æŸ¥è¯¢
- **æ“ä½œç¥¨ä¸“å®¶**: ä¸“æ³¨äºå€’é—¸æ“ä½œç¥¨çš„ç¼–åˆ¶å’Œå®¡æ ¸
- **äº‹æ•…é¢„æƒ³ä¸“å®¶**: ä¸“æ³¨äºäº‹æ•…æ¨æ¼”å’Œåº”æ€¥é¢„æ¡ˆ

### 2. è§’è‰²-èƒ½åŠ›-å·¥å…·ä¸‰ä½ä¸€ä½“

```python
class BaseAgent:
    def __init__(
        self,
        role: AgentRole,           # è§’è‰²å®šä½
        name: str,                 # äººæ ¼åŒ–åç§°
        description: str,          # èŒè´£æè¿°
        tools: List[str]           # å¯ç”¨å·¥å…·é›†
    ):
        ...
```

**è®¾è®¡æ€è·¯**:
1. **è§’è‰² (Role)**: å®šä¹‰"æˆ‘æ˜¯è°" - èº«ä»½è®¤åŒ
2. **èƒ½åŠ› (Capability)**: å®šä¹‰"æˆ‘èƒ½åšä»€ä¹ˆ" - æ ¸å¿ƒèŒè´£
3. **å·¥å…· (Tools)**: å®šä¹‰"æˆ‘ç”¨ä»€ä¹ˆåš" - æ‰§è¡Œæ‰‹æ®µ

**ç¤ºä¾‹ - å›¾è°±ä¸“å®¶**:
```python
ArchivistAgent(
    role=AgentRole.ARCHIVIST,                    # è§’è‰²: å›¾è°±ä¸“å®¶
    name="å›¾è°±ä¸“å®¶ (Archivist)",                  # åç§°: äººæ ¼åŒ–
    description="æ‹¥æœ‰å…¨å±€çŸ¥è¯†åº“çš„è®¿é—®æƒé™...",     # èƒ½åŠ›: æ£€ç´¢ä¸“å®¶
    tools=["global_search", "graph_traversal", "rag"]  # å·¥å…·: æ£€ç´¢å·¥å…·é›†
)
```

### 3. æ¨¡æ¿æ–¹æ³•æ¨¡å¼ (Template Method Pattern)

**è®¾è®¡ç›®çš„**: ç»Ÿä¸€æ‰§è¡Œæµç¨‹ï¼Œä¸ªæ€§åŒ–ä¸šåŠ¡é€»è¾‘

```python
# BaseAgent å®šä¹‰æ‰§è¡Œæ¨¡æ¿
async def run(self, state: AgentState, input_data: Dict) -> Dict:
    """ç»Ÿä¸€çš„æ‰§è¡Œæ¨¡æ¿"""
    try:
        # 1. å‰ç½®: è®°å½•å¼€å§‹æ€è€ƒ
        self._log_thought(state, "thought", f"{self.name} å¼€å§‹æ¥æ”¶ä»»åŠ¡")
        
        # 2. æ ¸å¿ƒ: æ‰§è¡Œå…·ä½“ä¸šåŠ¡é€»è¾‘ (ç”±å­ç±»å®ç°)
        result = await self._execute(state, input_data)
        
        # 3. åç½®: è®°å½•æ‰§è¡Œå®Œæˆ
        self._log_thought(state, "final_answer", f"{self.name} ä»»åŠ¡å®Œæˆ")
        
        return result
    except Exception as e:
        # 4. å¼‚å¸¸å¤„ç†
        self._log_thought(state, "correction", f"å‘ç”Ÿé”™è¯¯: {str(e)}")
        raise
```

**ä¼˜åŠ¿**:
- âœ… ç»Ÿä¸€çš„æ—¥å¿—è®°å½•
- âœ… ç»Ÿä¸€çš„å¼‚å¸¸å¤„ç†
- âœ… ç»Ÿä¸€çš„æ€ç»´é“¾è¿½è¸ª
- âœ… çµæ´»çš„ä¸šåŠ¡é€»è¾‘æ‰©å±•

---

## æ¶æ„åˆ†å±‚è®¾è®¡

### 1. æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     å‰ç«¯å±•ç¤ºå±‚                                â”‚
â”‚  - WebSocket å®æ—¶é€šä¿¡                                         â”‚
â”‚  - æ€ç»´é“¾æ°”æ³¡å¯è§†åŒ–                                           â”‚
â”‚  - å·¥å…·è°ƒç”¨è¿½è¸ª                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  æœåŠ¡ç¼–æ’å±‚                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ AgentChatService â”‚  â”‚ AgentOrchestratorâ”‚                 â”‚
â”‚  â”‚ (æ¶ˆæ¯å¤„ç†)        â”‚  â”‚ (æ™ºèƒ½ä½“åä½œ)      â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  æ™ºèƒ½ä½“æ³¨å†Œå±‚                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              AgentRegistry (IoCå®¹å™¨)                  â”‚   â”‚
â”‚  â”‚  - æ™ºèƒ½ä½“æ³¨å†Œä¸å‘ç°                                    â”‚   â”‚
â”‚  â”‚  - èƒ½åŠ›ç´¢å¼• (capability_index)                        â”‚   â”‚
â”‚  â”‚  - å…ƒæ•°æ®ç®¡ç† (metadata)                              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  æ™ºèƒ½ä½“æ‰§è¡Œå±‚                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                            â”‚
â”‚  â”‚  BaseAgent   â”‚ (æŠ½è±¡åŸºç±»)                                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                            â”‚
â”‚         â†“                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ Archivist    â”‚ Supervisor   â”‚ Accident     â”‚             â”‚
â”‚  â”‚ (å›¾è°±ä¸“å®¶)    â”‚ (å€¼ç­é•¿)      â”‚ Deduction    â”‚             â”‚
â”‚  â”‚              â”‚              â”‚ (äº‹æ•…é¢„æƒ³)    â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  åŸºç¡€èƒ½åŠ›å±‚                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ MCPå·¥å…·è°ƒç”¨   â”‚ RAGæ£€ç´¢æœåŠ¡   â”‚ æ¨¡æ¿æ¸²æŸ“æœåŠ¡  â”‚             â”‚
â”‚  â”‚ (LLM+Tools)  â”‚ (Knowledge)  â”‚ (Jinja2)     â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. åˆ†å±‚èŒè´£

#### 2.1 å‰ç«¯å±•ç¤ºå±‚
- **èŒè´£**: ç”¨æˆ·äº¤äº’å’Œå¯è§†åŒ–
- **æŠ€æœ¯**: WebSocket + React
- **ç‰¹è‰²**: æ€ç»´é“¾æ°”æ³¡å®æ—¶å±•ç¤º

#### 2.2 æœåŠ¡ç¼–æ’å±‚
- **AgentChatService**: 
  - WebSocketæ¶ˆæ¯å¤„ç†
  - æ¶ˆæ¯é˜Ÿåˆ—ç®¡ç†
  - æµå¼å“åº”
- **AgentOrchestrator**:
  - å¤šæ™ºèƒ½ä½“ä»»åŠ¡åˆ†å‘
  - åä½œæ¨¡å¼ç®¡ç† (å¹¶è¡Œ/ä¸²è¡Œ)
  - ç»“æœæ•´åˆ

#### 2.3 æ™ºèƒ½ä½“æ³¨å†Œå±‚
- **AgentRegistry**:
  - IoCå®¹å™¨ (æ§åˆ¶åè½¬)
  - èƒ½åŠ›ç´¢å¼• (capability â†’ agents)
  - å…ƒæ•°æ®ç®¡ç† (çŸ¥è¯†åº“ã€æç¤ºè¯ã€æ¨¡æ¿)

#### 2.4 æ™ºèƒ½ä½“æ‰§è¡Œå±‚
- **BaseAgent**: æŠ½è±¡åŸºç±»
  - æ¨¡æ¿æ–¹æ³•æ¨¡å¼
  - æ€ç»´é“¾è®°å½•
  - MCPä¼šè¯ç®¡ç†
- **ä¸“å®¶æ™ºèƒ½ä½“**: å…·ä½“å®ç°
  - é¢†åŸŸé€»è¾‘
  - å·¥å…·è°ƒç”¨
  - ç»“æœæ ¼å¼åŒ–

#### 2.5 åŸºç¡€èƒ½åŠ›å±‚
- **MCPå·¥å…·è°ƒç”¨**: LLM + å·¥å…·é›†æˆ
- **RAGæ£€ç´¢**: å‘é‡+å›¾è°±æ··åˆæ£€ç´¢
- **æ¨¡æ¿æ¸²æŸ“**: Jinja2æ¨¡æ¿å¼•æ“

---

## å›¾è°±ä¸“å®¶æ·±åº¦å‰–æ

### 1. ç±»è®¾è®¡æ¦‚è§ˆ

```python
class ArchivistAgent(BaseAgent):
    """
    å›¾è°±ä¸“å®¶ (The Archivist)
    
    èŒè´£ï¼š
    - çŸ¥è¯†åº“æ£€ç´¢
    - å›¾è°±å…³ç³»éå†
    - å†å²æ•°æ®æŸ¥è¯¢
    - çŸ¥è¯†æ•´åˆ
    """
```

### 2. æ ¸å¿ƒèƒ½åŠ›åˆ†è§£

#### 2.1 æ™ºèƒ½è·¯ç”± (Intelligent Routing)

**è®¾è®¡æ€è·¯**: æ ¹æ®æŸ¥è¯¢æ„å›¾è‡ªåŠ¨è·¯ç”±åˆ°ä¸åŒçš„å¤„ç†æ–¹æ³•

```python
async def _execute(self, state: AgentState, input_data: Dict) -> Dict:
    query = input_data.get("query", "")
    search_type = input_data.get("search_type", "hybrid")
    
    # æ„å›¾è¯†åˆ« â†’ è·¯ç”±å†³ç­–
    if any(keyword in query for keyword in ["å…³ç³»", "è¿æ¥", "è·¯å¾„", "å…³è”"]):
        return await self._graph_traversal(state, query)  # å›¾è°±éå†
    elif any(keyword in query for keyword in ["å†å²", "æ¡ˆä¾‹", "è®°å½•"]):
        return await self._historical_search(state, query)  # å†å²æŸ¥è¯¢
    else:
        return await self._knowledge_search(state, query, search_type)  # çŸ¥è¯†æ£€ç´¢
```

**è·¯ç”±é€»è¾‘**:
```
ç”¨æˆ·æŸ¥è¯¢
    â†“
æ„å›¾è¯†åˆ« (å…³é”®è¯åŒ¹é…)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å›¾è°±éå† â”‚ å†å²æŸ¥è¯¢ â”‚ çŸ¥è¯†æ£€ç´¢ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2.2 çŸ¥è¯†æ£€ç´¢ (Knowledge Search)

**è®¾è®¡äº®ç‚¹**: ç›´æ¥è°ƒç”¨Serviceå±‚ï¼Œç»•è¿‡LLMå·¥å…·è°ƒç”¨

```python
async def _knowledge_search(
    self,
    state: AgentState,
    query: str,
    search_type: str,
    collection_ids: Optional[List[str]] = None
) -> Dict[str, Any]:
    """çŸ¥è¯†åº“æ£€ç´¢"""
    
    # 1. çŸ¥è¯†åº“è‡ªåŠ¨å‘ç°
    if not collection_ids:
        from aperag.service.collection_service import collection_service
        collections = await collection_service.get_all_collections(self.user_id)
        collection_ids = [str(c.id) for c in collections]
    
    # 2. ä½¿ç”¨BaseAgentçš„æ£€ç´¢èƒ½åŠ› (ç›´æ¥è°ƒç”¨Service)
    results = await self._search_knowledge(
        state=state,
        query=query,
        collection_ids=collection_ids,
        top_k=10
    )
    
    # 3. æå–æ–‡æ¡£
    documents = self._extract_documents_from_tool_results(results)
    
    # 4. æ ¼å¼åŒ–è¾“å‡º
    report = self._format_search_results(query, documents)
    
    return {
        "answer": report,
        "documents": documents,
        "count": len(documents)
    }
```

**ä¸ºä»€ä¹ˆç»•è¿‡LLMå·¥å…·è°ƒç”¨?**
- âš¡ **æ€§èƒ½**: ç›´æ¥è°ƒç”¨æ›´å¿«
- ğŸ¯ **ç²¾å‡†**: é¿å…LLMç†è§£åå·®
- ğŸ’° **æˆæœ¬**: å‡å°‘Tokenæ¶ˆè€—
- ğŸ”§ **å¯æ§**: å‚æ•°å®Œå…¨å¯æ§

#### 2.3 å›¾è°±éå† (Graph Traversal)

**è®¾è®¡æ€è·¯**: LLMæ„å›¾ç†è§£ + ç»“æ„åŒ–æ•°æ®æå–

```python
async def _graph_traversal(self, state: AgentState, query: str) -> Dict:
    """å›¾è°±å…³ç³»éå†"""
    
    # æ­¥éª¤1: ä½¿ç”¨LLMåˆ†ææŸ¥è¯¢æ„å›¾
    intent_prompt = f"""
åˆ†æä»¥ä¸‹æŸ¥è¯¢çš„å›¾è°±éå†éœ€æ±‚ï¼š
æŸ¥è¯¢: {query}

è¯·æå–ï¼š
1. èµ·å§‹èŠ‚ç‚¹ï¼ˆè®¾å¤‡åç§°ï¼‰
2. ç›®æ ‡èŠ‚ç‚¹ï¼ˆå¦‚æœæœ‰ï¼‰
3. å…³ç³»ç±»å‹ï¼ˆå¦‚ï¼šè¿æ¥ã€ä¾›ç”µã€ä¿æŠ¤ç­‰ï¼‰
4. éå†æ·±åº¦ï¼ˆ1-3ï¼‰

ä»¥JSONæ ¼å¼è¾“å‡ºï¼š
{{
    "start_node": "èµ·å§‹èŠ‚ç‚¹",
    "target_node": "ç›®æ ‡èŠ‚ç‚¹æˆ–null",
    "relation_type": "å…³ç³»ç±»å‹",
    "depth": 2
}}
"""
    
    intent_json = await self._generate_with_llm(
        state=state,
        prompt=intent_prompt,
        temperature=0.3,  # ä½æ¸©åº¦ä¿è¯æ ¼å¼ç¨³å®š
        max_tokens=500
    )
    
    # æ­¥éª¤2: è§£ææ„å›¾
    import json, re
    cleaned_intent = re.sub(r"```json|```", "", intent_json).strip()
    intent = json.loads(cleaned_intent)
    
    # æ­¥éª¤3: æ‰§è¡Œå›¾è°±æŸ¥è¯¢ (å†æ¬¡è°ƒç”¨LLMï¼Œè¦æ±‚è¿”å›ç»“æ„åŒ–æ•°æ®)
    traversal_prompt = f"""
è¯·æŸ¥è¯¢çŸ¥è¯†å›¾è°±ä¸­çš„å…³ç³»ï¼š
èµ·å§‹èŠ‚ç‚¹: {intent.get('start_node')}
ç›®æ ‡èŠ‚ç‚¹: {intent.get('target_node', 'æ‰€æœ‰ç›¸å…³èŠ‚ç‚¹')}
å…³ç³»ç±»å‹: {intent.get('relation_type', 'æ‰€æœ‰å…³ç³»')}
éå†æ·±åº¦: {intent.get('depth', 2)}

è¯·è¿”å›ä¸¤éƒ¨åˆ†å†…å®¹ï¼š
1. è‡ªç„¶è¯­è¨€æè¿°ï¼šæè¿°æ‰¾åˆ°çš„å…³ç³»å’Œè·¯å¾„ã€‚
2. ç»“æ„åŒ–æ•°æ®ï¼šä»¥JSONæ ¼å¼åˆ—å‡ºæ¶‰åŠçš„èŠ‚ç‚¹å’Œè¾¹ã€‚

æ ¼å¼è¦æ±‚ï¼š
[DESCRIPTION]
...è‡ªç„¶è¯­è¨€æè¿°...

[GRAPH_DATA]
{{
    "nodes": [
        {{"id": "èŠ‚ç‚¹ID", "label": "èŠ‚ç‚¹åç§°", "type": "è®¾å¤‡ç±»å‹"}}
    ],
    "edges": [
        {{"source": "æºèŠ‚ç‚¹ID", "target": "ç›®æ ‡èŠ‚ç‚¹ID", "label": "å…³ç³»ç±»å‹"}}
    ]
}}
"""
    
    traversal_result_raw = await self._generate_with_llm(
        state=state,
        prompt=traversal_prompt,
        temperature=0.5
    )
    
    # æ­¥éª¤4: è§£æç»“æœ (è‡ªç„¶è¯­è¨€ + ç»“æ„åŒ–æ•°æ®)
    description = traversal_result_raw
    graph_data = {"nodes": [], "edges": []}
    
    if "[GRAPH_DATA]" in traversal_result_raw:
        parts = traversal_result_raw.split("[GRAPH_DATA]")
        description = parts[0].replace("[DESCRIPTION]", "").strip()
        try:
            graph_json_str = parts[1].strip()
            graph_json_str = re.sub(r"```json|```", "", graph_json_str).strip()
            graph_data = json.loads(graph_json_str)
        except Exception as e:
            logger.warning(f"Failed to parse graph data: {e}")
    
    return {
        "answer": description,
        "intent": intent,
        "graph_data": graph_data
    }
```

**è®¾è®¡äº®ç‚¹**:
1. **ä¸¤é˜¶æ®µLLMè°ƒç”¨**:
   - ç¬¬ä¸€é˜¶æ®µ: æ„å›¾ç†è§£ (æå–ç»“æ„åŒ–å‚æ•°)
   - ç¬¬äºŒé˜¶æ®µ: å›¾è°±æŸ¥è¯¢ (ç”Ÿæˆè‡ªç„¶è¯­è¨€+ç»“æ„åŒ–æ•°æ®)

2. **ç»“æ„åŒ–æ•°æ®æå–**:
   - ä½¿ç”¨ç‰¹æ®Šæ ‡è®° `[DESCRIPTION]` å’Œ `[GRAPH_DATA]` åˆ†éš”
   - æ­£åˆ™æ¸…ç†Markdownä»£ç å—æ ‡è®°
   - JSONè§£æ + å¼‚å¸¸å¤„ç†

3. **å‰ç«¯å¯è§†åŒ–æ”¯æŒ**:
   - `description`: è‡ªç„¶è¯­è¨€è§£é‡Š
   - `graph_data`: å›¾è°±å¯è§†åŒ–æ•°æ® (nodes + edges)

#### 2.4 å†å²æ•°æ®æŸ¥è¯¢ (Historical Search)

**è®¾è®¡ç‰¹ç‚¹**: æ—¶é—´æ’åº + æ›´å¤šç»“æœ

```python
async def _historical_search(
    self,
    state: AgentState,
    query: str,
    collection_ids: Optional[List[str]] = None
) -> Dict:
    """å†å²æ•°æ®æŸ¥è¯¢"""
    
    # 1. æ£€ç´¢å†å²è®°å½• (top_k=20ï¼Œæ¯”æ™®é€šæ£€ç´¢æ›´å¤š)
    results = await self._search_knowledge(
        state=state,
        query=query,
        collection_ids=collection_ids,
        top_k=20  # å†å²æŸ¥è¯¢è¿”å›æ›´å¤šç»“æœ
    )
    
    documents = self._extract_documents_from_tool_results(results)
    
    # 2. æŒ‰æ—¶é—´æ’åº (å¦‚æœæœ‰æ—¶é—´æˆ³)
    sorted_docs = sorted(
        documents,
        key=lambda x: x.get('timestamp', x.get('date', '')),
        reverse=True  # æœ€æ–°çš„åœ¨å‰
    )
    
    # 3. æ ¼å¼åŒ–å†å²ç»“æœ (åŒ…å«æ—¶é—´ä¿¡æ¯)
    report = self._format_historical_results(query, sorted_docs)
    
    return {
        "answer": report,
        "documents": sorted_docs,
        "count": len(sorted_docs)
    }
```

### 3. ç»“æœæ ¼å¼åŒ–ç­–ç•¥

#### 3.1 æ£€ç´¢ç»“æœæ ¼å¼åŒ–

```python
def _format_search_results(self, query: str, documents: List[Dict]) -> str:
    """æ ¼å¼åŒ–æ£€ç´¢ç»“æœ"""
    report = f"## æ£€ç´¢ç»“æœ\n\n"
    report += f"**æŸ¥è¯¢**: {query}\n"
    report += f"**æ‰¾åˆ°**: {len(documents)} æ¡ç›¸å…³æ–‡æ¡£\n\n"
    
    for i, doc in enumerate(documents[:10]):  # åªæ˜¾ç¤ºå‰10æ¡
        report += f"### {i+1}. {doc.get('title', 'æœªçŸ¥')}\n"
        report += f"**æ¥æº**: {doc.get('source', 'çŸ¥è¯†åº“')}\n"
        
        # æ˜¾ç¤ºå†…å®¹æ‘˜è¦ (æˆªæ–­åˆ°300å­—ç¬¦)
        content = doc.get('content', '')
        if len(content) > 300:
            content = content[:300] + "..."
        report += f"{content}\n\n"
    
    if len(documents) > 10:
        report += f"*è¿˜æœ‰ {len(documents) - 10} æ¡ç»“æœæœªæ˜¾ç¤º*\n"
    
    return report
```

**æ ¼å¼åŒ–ç­–ç•¥**:
- ğŸ“Š **ç»“æ„åŒ–**: Markdownæ ¼å¼ï¼Œå±‚æ¬¡æ¸…æ™°
- âœ‚ï¸ **æˆªæ–­**: å†…å®¹è¶…è¿‡300å­—ç¬¦è‡ªåŠ¨æˆªæ–­
- ğŸ“ **æ‘˜è¦**: åªæ˜¾ç¤ºå‰10æ¡ï¼Œé¿å…ä¿¡æ¯è¿‡è½½
- ğŸ“Œ **æ¥æº**: æ ‡æ³¨æ–‡æ¡£æ¥æºï¼Œæ”¯æŒæº¯æº

#### 3.2 å†å²ç»“æœæ ¼å¼åŒ–

```python
def _format_historical_results(self, query: str, documents: List[Dict]) -> str:
    """æ ¼å¼åŒ–å†å²ç»“æœ"""
    report = f"## å†å²è®°å½•\n\n"
    report += f"**æŸ¥è¯¢**: {query}\n"
    report += f"**æ‰¾åˆ°**: {len(documents)} æ¡å†å²è®°å½•\n\n"
    
    for i, doc in enumerate(documents[:15]):  # å†å²è®°å½•æ˜¾ç¤ºæ›´å¤š
        report += f"### {i+1}. {doc.get('title', 'æœªçŸ¥')}\n"
        
        # æ˜¾ç¤ºæ—¶é—´ä¿¡æ¯ (å†å²æŸ¥è¯¢çš„å…³é”®)
        timestamp = doc.get('timestamp', doc.get('date', 'æœªçŸ¥æ—¶é—´'))
        report += f"**æ—¶é—´**: {timestamp}\n"
        
        # æ˜¾ç¤ºç±»å‹
        doc_type = doc.get('type', doc.get('category', 'æœªçŸ¥ç±»å‹'))
        report += f"**ç±»å‹**: {doc_type}\n"
        
        # æ˜¾ç¤ºå†…å®¹æ‘˜è¦ (æˆªæ–­åˆ°200å­—ç¬¦)
        content = doc.get('content', '')
        if len(content) > 200:
            content = content[:200] + "..."
        report += f"{content}\n\n"
    
    if len(documents) > 15:
        report += f"*è¿˜æœ‰ {len(documents) - 15} æ¡è®°å½•æœªæ˜¾ç¤º*\n"
    
    return report
```

**å†å²ç»“æœç‰¹ç‚¹**:
- â° **æ—¶é—´ä¼˜å…ˆ**: çªå‡ºæ˜¾ç¤ºæ—¶é—´æˆ³
- ğŸ·ï¸ **ç±»å‹æ ‡æ³¨**: æ˜¾ç¤ºæ–‡æ¡£ç±»å‹/åˆ†ç±»
- ğŸ“ˆ **æ›´å¤šç»“æœ**: æ˜¾ç¤º15æ¡ (vs æ™®é€šæ£€ç´¢10æ¡)

### 4. å›é€€æœºåˆ¶ (Fallback)

**è®¾è®¡å“²å­¦**: æ°¸è¿œä¸è¦è®©ç”¨æˆ·çœ‹åˆ°ç©ºç™½æˆ–é”™è¯¯

```python
def _fallback_response(self, query: str) -> Dict[str, Any]:
    """å›é€€å“åº”ï¼ˆä½¿ç”¨Mockæ•°æ®ï¼‰"""
    # Mockæ•°æ®åº“
    mock_db = [
        {
            "id": "doc_001",
            "title": "1å·ä¸»å˜æ£€ä¿®è®°å½•_202405",
            "content": "2024å¹´5æœˆ12æ—¥ï¼Œå¯¹1å·ä¸»å˜è¿›è¡Œäº†ä¾‹è¡Œæ£€ä¿®...",
            "source": "æ£€ä¿®è®°å½•åº“",
            "timestamp": "2024-05-12"
        },
        {
            "id": "kb_node_102",
            "title": "è®¾å¤‡å°è´¦: #1 ä¸»å˜å‹å™¨",
            "content": "å‹å·: SFZ11-110000/110; å‚å®¶: ç‰¹å˜ç”µå·¥...",
            "source": "è®¾å¤‡å°è´¦",
            "type": "è®¾å¤‡ä¿¡æ¯"
        },
        # ... æ›´å¤šMockæ•°æ®
    ]
    
    # ç®€å•çš„å…³é”®è¯åŒ¹é…
    results = []
    query_lower = query.lower()
    for item in mock_db:
        if any(keyword in query_lower for keyword in ["ä¸»å˜", "å˜å‹å™¨", "æ£€ä¿®", "å°è´¦", "è§„ç¨‹"]):
            results.append(item)
    
    if not results:
        results = mock_db  # è¿”å›æ‰€æœ‰Mockæ•°æ®
    
    report = self._format_search_results(query, results)
    
    return {
        "answer": report,
        "documents": results,
        "count": len(results),
        "note": "ä½¿ç”¨Mockæ•°æ®ï¼Œå®é™…éƒ¨ç½²æ—¶å°†è¿æ¥çœŸå®çŸ¥è¯†åº“"
    }
```

**å›é€€è§¦å‘æ¡ä»¶**:
1. æ²¡æœ‰ `user_id` (æ— æ³•è®¿é—®çœŸå®çŸ¥è¯†åº“)
2. çŸ¥è¯†åº“æ£€ç´¢å¤±è´¥ (å¼‚å¸¸æ•è·)
3. LLMç”Ÿæˆå¤±è´¥ (å¼‚å¸¸æ•è·)

**å›é€€ç­–ç•¥**:
- ğŸ­ **Mockæ•°æ®**: æä¾›ç¤ºä¾‹æ•°æ®
- ğŸ” **å…³é”®è¯åŒ¹é…**: ç®€å•çš„ç›¸å…³æ€§è¿‡æ»¤
- ğŸ’¡ **æç¤ºä¿¡æ¯**: å‘ŠçŸ¥ç”¨æˆ·å½“å‰ä½¿ç”¨Mockæ•°æ®

---

## é€šç”¨è®¾è®¡æ¨¡å¼

### 1. æ¨¡æ¿æ–¹æ³•æ¨¡å¼ (Template Method)

**åº”ç”¨åœºæ™¯**: BaseAgent.run()

```python
# æ¨¡æ¿æ–¹æ³• (BaseAgent)
async def run(self, state: AgentState, input_data: Dict) -> Dict:
    try:
        # 1. å‰ç½®é’©å­
        self._log_thought(state, "thought", f"{self.name} å¼€å§‹æ¥æ”¶ä»»åŠ¡")
        
        # 2. æ ¸å¿ƒé€»è¾‘ (æŠ½è±¡æ–¹æ³•ï¼Œç”±å­ç±»å®ç°)
        result = await self._execute(state, input_data)
        
        # 3. åç½®é’©å­
        self._log_thought(state, "final_answer", f"{self.name} ä»»åŠ¡å®Œæˆ")
        
        return result
    except Exception as e:
        # 4. å¼‚å¸¸é’©å­
        self._log_thought(state, "correction", f"å‘ç”Ÿé”™è¯¯: {str(e)}")
        raise

# å…·ä½“å®ç° (ArchivistAgent)
async def _execute(self, state: AgentState, input_data: Dict) -> Dict:
    # å›¾è°±ä¸“å®¶çš„å…·ä½“é€»è¾‘
    query = input_data.get("query", "")
    if "å…³ç³»" in query:
        return await self._graph_traversal(state, query)
    # ...
```

**ä¼˜åŠ¿**:
- âœ… ç»Ÿä¸€æµç¨‹æ§åˆ¶
- âœ… çµæ´»ä¸šåŠ¡æ‰©å±•
- âœ… ä»£ç å¤ç”¨

### 2. ç­–ç•¥æ¨¡å¼ (Strategy Pattern)

**åº”ç”¨åœºæ™¯**: å›¾è°±ä¸“å®¶çš„è·¯ç”±ç­–ç•¥

```python
# ç­–ç•¥æ¥å£ (éšå¼)
async def _execute(self, state, input_data):
    query = input_data.get("query", "")
    
    # ç­–ç•¥é€‰æ‹©
    if "å…³ç³»" in query:
        strategy = self._graph_traversal  # å›¾è°±éå†ç­–ç•¥
    elif "å†å²" in query:
        strategy = self._historical_search  # å†å²æŸ¥è¯¢ç­–ç•¥
    else:
        strategy = self._knowledge_search  # çŸ¥è¯†æ£€ç´¢ç­–ç•¥
    
    # æ‰§è¡Œç­–ç•¥
    return await strategy(state, query)
```

### 3. ä¾èµ–æ³¨å…¥ (Dependency Injection)

**åº”ç”¨åœºæ™¯**: æœåŠ¡ä¾èµ–

```python
class ArchivistAgent(BaseAgent):
    def __init__(self, retrieve_service: Any = None):
        super().__init__(...)
        self.retrieve_service = retrieve_service  # æ³¨å…¥æ£€ç´¢æœåŠ¡
```

**ä¼˜åŠ¿**:
- ğŸ”§ **è§£è€¦**: é™ä½ç»„ä»¶è€¦åˆåº¦
- ğŸ§ª **å¯æµ‹è¯•**: æ–¹ä¾¿Mockå’Œå•å…ƒæµ‹è¯•
- ğŸ”„ **å¯æ›¿æ¢**: è½»æ¾åˆ‡æ¢å®ç°

### 4. è§‚å¯Ÿè€…æ¨¡å¼ (Observer Pattern)

**åº”ç”¨åœºæ™¯**: æ€ç»´é“¾è®°å½•

```python
# ä¸»é¢˜ (Subject): AgentState
class AgentState(BaseModel):
    thinking_stream: List[AgentThinkingStep] = []
    
    def add_thought(self, step: AgentThinkingStep):
        self.thinking_stream.append(step)  # é€šçŸ¥è§‚å¯Ÿè€…

# è§‚å¯Ÿè€… (Observer): å‰ç«¯WebSocket
# é€šè¿‡WebSocketå®æ—¶æ¨é€æ€ç»´é“¾æ›´æ–°
```

### 5. å»ºé€ è€…æ¨¡å¼ (Builder Pattern)

**åº”ç”¨åœºæ™¯**: æç¤ºè¯æ„å»º

```python
def _build_deduction_prompt(
    self,
    equipment: str,
    scenario: str,
    query: str,
    context: str
) -> str:
    """æ„å»ºLLMç”Ÿæˆæç¤ºè¯"""
    prompt = f"""
è¯·æ ¹æ®ä»¥ä¸‹ä¿¡æ¯ç”Ÿæˆä¸€ä»½è¯¦ç»†çš„äº‹æ•…æ¨æ¼”æŠ¥å‘Šæ•°æ®ï¼ˆJSONæ ¼å¼ï¼‰ï¼š

**è®¾å¤‡**: {equipment}
**äº‹æ•…åœºæ™¯**: {scenario}
**ä»»åŠ¡**: {query}

{context}

è¯·ç”ŸæˆåŒ…å«ä»¥ä¸‹å­—æ®µçš„JSONå¯¹è±¡ï¼š
{{
    "report_no": "æ¨æ¼”æŠ¥å‘Šç¼–å·",
    "deduction_date": "æ¨æ¼”æ—¥æœŸ",
    ...
}}
"""
    return prompt
```

---

## æ™ºèƒ½ä½“åä½œæœºåˆ¶

### 1. å€¼ç­é•¿ (Supervisor) åä½œæ¨¡å¼

**è®¾è®¡ç†å¿µ**: ä¸­å¤®åè°ƒå™¨ + ä¸“å®¶å›¢é˜Ÿ

```python
class SupervisorAgent(BaseAgent):
    """å€¼ç­é•¿æ™ºèƒ½ä½“ - æ€»æ§å¤§è„‘"""
    
    async def _execute(self, state: AgentState, input_data: Dict) -> Dict:
        query = input_data.get("task", "")
        
        # 1. ä»»åŠ¡åˆ†æ
        task_analysis = await self._analyze_task(state, query)
        
        # 2. åˆ¤æ–­æ˜¯å¦éœ€è¦åä½œ
        if task_analysis['requires_collaboration']:
            return await self._coordinate_collaboration(state, query, task_analysis)
        else:
            return await self._handle_single_task(state, query, task_analysis)
```

### 2. ä»»åŠ¡åˆ†æç­–ç•¥

**ä¸¤é˜¶æ®µåˆ†æ**: LLMæ„å›¾è¯†åˆ« + è§„åˆ™å›é€€

```python
async def _analyze_task(self, state: AgentState, query: str) -> Dict:
    """åˆ†æä»»åŠ¡ç±»å‹å’Œå¤æ‚åº¦"""
    
    # é˜¶æ®µ1: å°è¯•ä½¿ç”¨ LLM è¿›è¡Œåˆ†æ
    try:
        prompt = f"""
ä½ æ˜¯ä¸€ä¸ªå˜ç”µç«™å€¼ç­é•¿æ™ºèƒ½ä½“ã€‚è¯·åˆ†æä»¥ä¸‹ç”¨æˆ·æŒ‡ä»¤ï¼Œå¹¶æå–ä»»åŠ¡å…³é”®ä¿¡æ¯ã€‚

ç”¨æˆ·æŒ‡ä»¤: "{query}"

è¯·åˆ†æå¹¶è¿”å›å¦‚ä¸‹ JSON æ ¼å¼:
{{
    "task_type": "ä»»åŠ¡ç±»å‹(emergency_response/operation_planning/...)",
    "complexity": "å¤æ‚åº¦(high/medium/low)",
    "priority": "ä¼˜å…ˆçº§(urgent/high/normal)",
    "requires_collaboration": true/false,
    "involved_agents": ["æ¶‰åŠçš„æ™ºèƒ½ä½“è§’è‰²ID"],
    "reasoning": "ç®€çŸ­çš„åˆ†æç†ç”±"
}}
"""
        response = await self._generate_with_llm(
            state=state,
            prompt=prompt,
            temperature=0.1,  # ä½æ¸©åº¦ä¿è¯æ ¼å¼ç¨³å®š
            max_tokens=500
        )
        
        analysis = json.loads(response)
        if "task_type" in analysis:
            return analysis
    
    except Exception as e:
        logger.warning(f"LLMåˆ†æå¤±è´¥ï¼Œå›é€€åˆ°è§„åˆ™åŒ¹é…: {e}")
    
    # é˜¶æ®µ2: å›é€€åˆ°å…³é”®è¯åŒ¹é…
    analysis = {
        "task_type": "unknown",
        "complexity": "low",
        "requires_collaboration": False,
        "priority": "normal",
        "involved_agents": [],
        "reasoning": "åŸºäºå…³é”®è¯è§„åˆ™åŒ¹é…"
    }
    
    # äº‹æ•…ç›¸å…³
    if any(keyword in query for keyword in ["äº‹æ•…", "æ•…éšœ", "è·³é—¸", "å¼‚å¸¸", "å‘Šè­¦"]):
        analysis["task_type"] = "emergency_response"
        analysis["complexity"] = "high"
        analysis["requires_collaboration"] = True
        analysis["priority"] = "urgent"
        analysis["involved_agents"] = ["accident_deduction", "diagnosis", "operation_ticket"]
    
    # æ“ä½œç›¸å…³
    elif any(keyword in query for keyword in ["æ“ä½œ", "å€’é—¸", "æŠ•è¿", "åœè¿"]):
        analysis["task_type"] = "operation_planning"
        analysis["complexity"] = "medium"
        analysis["requires_collaboration"] = True
        analysis["priority"] = "high"
        analysis["involved_agents"] = ["operation_ticket", "accident_deduction", "work_permit"]
    
    # ... æ›´å¤šè§„åˆ™
    
    return analysis
```

**è®¾è®¡äº®ç‚¹**:
1. **æ™ºèƒ½ä¼˜å…ˆ**: ä¼˜å…ˆä½¿ç”¨LLMè¿›è¡Œç²¾å‡†æ„å›¾è¯†åˆ«
2. **è§„åˆ™å›é€€**: LLMå¤±è´¥æ—¶å›é€€åˆ°å…³é”®è¯åŒ¹é…
3. **ç»“æ„åŒ–è¾“å‡º**: ç»Ÿä¸€çš„JSONæ ¼å¼
4. **ä½æ¸©åº¦**: temperature=0.1 ä¿è¯è¾“å‡ºæ ¼å¼ç¨³å®š

### 3. åä½œç¼–æ’

```python
async def _coordinate_collaboration(
    self,
    state: AgentState,
    query: str,
    task_analysis: Dict
) -> Dict:
    """åè°ƒå¤šæ™ºèƒ½ä½“åä½œ"""
    
    # 1. ç¡®å®šä»»åŠ¡ç±»å‹
    task_type_map = {
        "emergency_response": TaskType.EMERGENCY_RESPONSE,
        "operation_planning": TaskType.OPERATION_PLANNING,
        "safety_check": TaskType.SAFETY_CHECK,
    }
    task_type = task_type_map.get(task_analysis["task_type"])
    
    # 2. ç¡®å®šåä½œæ¨¡å¼
    if task_analysis["priority"] == "urgent":
        mode = CollaborationMode.PARALLEL  # ç´§æ€¥ä»»åŠ¡å¹¶è¡Œæ‰§è¡Œ
    else:
        mode = CollaborationMode.SEQUENTIAL  # å¸¸è§„ä»»åŠ¡é¡ºåºæ‰§è¡Œ
    
    # 3. æ‰§è¡Œåä½œ
    result = await agent_orchestrator.execute_collaboration(
        task=query,
        task_type=task_type,
        user_id=self.user_id,
        chat_id=self.chat_id,
        mode=mode
    )
    
    return {
        "answer": result["integrated_report"],
        "collaboration_result": result,
        "task_analysis": task_analysis
    }
```

**åä½œæ¨¡å¼**:
```
å¹¶è¡Œæ¨¡å¼ (PARALLEL):
  ä»»åŠ¡
   â”œâ”€â†’ ä¸“å®¶A â”€â”
   â”œâ”€â†’ ä¸“å®¶B â”€â”¼â†’ ç»“æœæ•´åˆ
   â””â”€â†’ ä¸“å®¶C â”€â”˜

ä¸²è¡Œæ¨¡å¼ (SEQUENTIAL):
  ä»»åŠ¡ â†’ ä¸“å®¶A â†’ ä¸“å®¶B â†’ ä¸“å®¶C â†’ ç»“æœæ•´åˆ
```

---

## æ€ç»´é“¾å¯è§†åŒ–

### 1. æ€ç»´é“¾æ•°æ®ç»“æ„

```python
class AgentThinkingStep(BaseModel):
    """æ€è€ƒæ°”æ³¡æ•°æ®ç»“æ„"""
    
    step_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    role: AgentRole  # å“ªä¸ªæ™ºèƒ½ä½“çš„æ€è€ƒ
    step_type: Literal[
        "plan",          # è®¡åˆ’
        "thought",       # æ€è€ƒ
        "action",        # è¡ŒåŠ¨
        "observation",   # è§‚å¯Ÿ
        "correction",    # çº æ­£
        "final_answer"   # æœ€ç»ˆç­”æ¡ˆ
    ]
    
    description: str  # æ€è€ƒå†…å®¹
    detail: Optional[Dict[str, Any]] = None  # è¯¦ç»†ä¿¡æ¯
    citations: List[str] = []  # å¼•ç”¨æ¥æº
    timestamp: datetime = Field(default_factory=datetime.now)
```

### 2. æ€ç»´é“¾è®°å½•

```python
def _log_thought(
    self,
    state: AgentState,
    step_type: str,
    description: str,
    detail: Optional[Dict[str, Any]] = None,
    citations: Optional[List[str]] = None,
):
    """è®°å½•æ€è€ƒæ­¥éª¤"""
    step = AgentThinkingStep(
        role=self.role,
        step_type=step_type,
        description=description,
        detail=detail,
        citations=citations or [],
    )
    state.add_thought(step)
    # å¯ä»¥åœ¨æ­¤å¤„é€šè¿‡ WebSocket å®æ—¶æ¨é€åˆ°å‰ç«¯
```

### 3. æ€ç»´é“¾ç¤ºä¾‹

**å›¾è°±ä¸“å®¶çš„æ€ç»´é“¾**:
```
1. [thought] å›¾è°±ä¸“å®¶æ¥æ”¶æŸ¥è¯¢: æŸ¥è¯¢1å·ä¸»å˜çš„ä¿æŠ¤é…ç½®
2. [action] æ‰§è¡Œhybridæ£€ç´¢
3. [action] æ­£åœ¨æ£€ç´¢çŸ¥è¯†åº“: collection_1, collection_2
4. [observation] æ£€ç´¢å®Œæˆï¼Œæ‰¾åˆ° 8 æ¡ç›¸å…³æ–‡æ¡£
5. [final_answer] å›¾è°±ä¸“å®¶ ä»»åŠ¡å®Œæˆ
```

**äº‹æ•…é¢„æƒ³ä¸“å®¶çš„æ€ç»´é“¾**:
```
1. [thought] æ”¶åˆ°äº‹æ•…é¢„æƒ³ä»»åŠ¡: #1ä¸»å˜é‡ç“¦æ–¯ä¿æŠ¤åŠ¨ä½œäº‹æ•…é¢„æƒ³
2. [plan] å¼€å§‹ç¼–åˆ¶äº‹æ•…é¢„æƒ³æŠ¥å‘Š...
3. [action] åˆ†æåœºæ™¯: #1ä¸»å˜å‹å™¨ - é‡ç“¦æ–¯ä¿æŠ¤åŠ¨ä½œ
4. [action] æ­£åœ¨æ£€ç´¢å†å²äº‹æ•…æ¡ˆä¾‹...
5. [action] æ­£åœ¨æ£€ç´¢äº‹æ•…å¤„ç½®ç»éªŒ...
6. [observation] LLMç”Ÿæˆäº†äº‹æ•…æ¨æ¼”ï¼ŒåŒ…å« 3 ç§å¯èƒ½åŸå› 
7. [final_answer] äº‹æ•…é¢„æƒ³ä¸“å®¶ ä»»åŠ¡å®Œæˆ
```

### 4. å‰ç«¯å¯è§†åŒ–

**æ€ç»´æ°”æ³¡ç»„ä»¶** (ä¼ªä»£ç ):
```tsx
<ThinkingBubble
  role={step.role}
  type={step.step_type}
  description={step.description}
  detail={step.detail}
  timestamp={step.timestamp}
/>
```

**æ°”æ³¡æ ·å¼**:
- ğŸ§  **thought**: è“è‰²ï¼Œæ€è€ƒå›¾æ ‡
- ğŸ¯ **plan**: ç»¿è‰²ï¼Œè®¡åˆ’å›¾æ ‡
- âš¡ **action**: æ©™è‰²ï¼Œè¡ŒåŠ¨å›¾æ ‡
- ğŸ‘ï¸ **observation**: ç´«è‰²ï¼Œè§‚å¯Ÿå›¾æ ‡
- âš ï¸ **correction**: çº¢è‰²ï¼Œçº æ­£å›¾æ ‡
- âœ… **final_answer**: ç»¿è‰²ï¼Œå®Œæˆå›¾æ ‡

---

## å·¥å…·è°ƒç”¨æ¶æ„

### 1. MCP (Model Context Protocol) é›†æˆ

**è®¾è®¡ç†å¿µ**: LLM + å·¥å…· = å¢å¼ºæ™ºèƒ½ä½“

```python
async def _ensure_mcp_session(
    self,
    state: AgentState,
    model_provider: Optional[str] = None,
    model_name: Optional[str] = None,
    language: str = "zh-CN"
):
    """ç¡®ä¿MCPä¼šè¯å·²åˆå§‹åŒ–"""
    
    if self._mcp_session and self._llm:
        return
    
    # 1. è·å–é»˜è®¤æ¨¡å‹é…ç½®
    if not model_provider or not model_name:
        default_model, default_provider, _ = await self._get_default_conversation_llm()
        model_name = model_name or default_model
        model_provider = model_provider or default_provider
    
    # 2. è·å–ç³»ç»Ÿæç¤ºè¯
    system_prompt = agent_registry.get_system_prompt(self.role, language)
    
    # 3. æŸ¥è¯¢providerä¿¡æ¯å’ŒAPI key
    provider_info = await async_db_ops.query_llm_provider_by_name(model_provider)
    api_key = await async_db_ops.query_provider_api_key(model_provider, user_id=self.user_id)
    
    # 4. åˆ›å»ºAgentConfig
    config = AgentConfig(
        user_id=self.user_id,
        chat_id=self.chat_id,
        provider_name=model_provider,
        api_key=api_key,
        base_url=provider_info.base_url,
        default_model=model_name,
        language=language,
        instruction=system_prompt,
        server_names=["aperag"],  # MCPæœåŠ¡å™¨
        aperag_api_key=aperag_api_key,
        aperag_mcp_url=os.getenv("APERAG_MCP_URL"),
        temperature=0.7,
        max_tokens=60000,
    )
    
    # 5. è·å–æˆ–åˆ›å»ºä¼šè¯
    self._mcp_session = await agent_session_manager.get_or_create_session(config)
    self._llm = await self._mcp_session.get_llm(model_name)
```

### 2. çŸ¥è¯†æ£€ç´¢å·¥å…·

**ç›´æ¥è°ƒç”¨Serviceï¼Œç»•è¿‡LLM**:

```python
@trace_async_function("name=agent_search_knowledge", new_trace=True)
async def _search_knowledge(
    self,
    state: AgentState,
    query: str,
    collection_ids: Optional[List[str]] = None,
    top_k: int = 5,
) -> List[Dict[str, Any]]:
    """ä»çŸ¥è¯†åº“æ£€ç´¢æ–‡æ¡£ï¼ˆç›´æ¥è°ƒç”¨Serviceï¼Œç»•è¿‡LLMå·¥å…·è°ƒç”¨ï¼‰"""
    
    # 1. è®°å½•æ£€ç´¢æ“ä½œ
    self._log_thought(
        state,
        "action",
        f"æ­£åœ¨æ£€ç´¢çŸ¥è¯†åº“: {', '.join(collection_ids)}",
        detail={"query": query, "collections": collection_ids, "top_k": top_k}
    )
    
    # 2. è°ƒç”¨æœåŠ¡å±‚ç›´æ¥æœç´¢
    from aperag.service.collection_service import collection_service
    
    all_documents = []
    for col_id in collection_ids:
        search_request = view_models.SearchRequest(
            query=query,
            rerank=True,
            vector_search=view_models.VectorSearchParams(topk=top_k, similarity=0.2),
            fulltext_search=view_models.FulltextSearchParams(topk=top_k),
            graph_search=view_models.GraphSearchParams(topk=top_k),
            summary_search=view_models.SummarySearchParams(topk=top_k, similarity=0.2),
        )
        
        result = await collection_service.create_search(
            user=self.user_id,
            collection_id=col_id,
            data=search_request
        )
        
        if result.items:
            for item in result.items:
                doc = item.model_dump()
                all_documents.append(doc)
    
    # 3. æ’åºå’Œæˆªå–
    all_documents.sort(key=lambda x: x.get('score', 0) or 0, reverse=True)
    all_documents = all_documents[:top_k]
    
    # 4. æ„é€ ä¼ªé€ çš„å·¥å…·è°ƒç”¨ç»“æœï¼ˆå…¼å®¹æ ¼å¼ï¼‰
    fake_tool_result = {
        "tool_name": "search_collection",
        "arguments": {"query": query, "collection_ids": collection_ids},
        "result": {
            "documents": all_documents
        }
    }
    
    return [fake_tool_result]
```

**ä¸ºä»€ä¹ˆç›´æ¥è°ƒç”¨Service?**
1. **æ€§èƒ½**: é¿å…LLMç†è§£å»¶è¿Ÿ
2. **ç²¾å‡†**: å‚æ•°å®Œå…¨å¯æ§
3. **æˆæœ¬**: å‡å°‘Tokenæ¶ˆè€—
4. **å¯é **: é¿å…LLMå·¥å…·è°ƒç”¨å¤±è´¥

### 3. ç½‘ç»œæœç´¢å·¥å…·

**ä½¿ç”¨MCPå·¥å…·è°ƒç”¨**:

```python
async def _web_search(
    self,
    state: AgentState,
    query: str,
    num_results: int = 5,
) -> List[Dict[str, Any]]:
    """ç½‘ç»œæœç´¢ï¼ˆä½¿ç”¨MCPå·¥å…·ï¼‰"""
    
    # 1. ç¡®ä¿MCPä¼šè¯å·²åˆå§‹åŒ–
    await self._ensure_mcp_session(state)
    
    # 2. æ„å»º AgentMessage
    agent_message = view_models.AgentMessage(
        query=query,
        collections=[],
        completion=view_models.ModelSpec(...),
        web_search_enabled=True,  # å¯ç”¨ç½‘ç»œæœç´¢
    )
    
    # 3. ä½¿ç”¨ build_agent_query_prompt æ„å»ºç»¼åˆæç¤ºè¯
    comprehensive_prompt = build_agent_query_prompt(
        chat_id=self.chat_id,
        agent_message=agent_message,
        user=self.user_id,
    )
    
    # 4. è°ƒç”¨ LLMï¼Œè®©å®ƒè‡ªä¸»å†³å®šä½•æ—¶è°ƒç”¨ web_search å·¥å…·
    llm = await self._mcp_session.get_llm(model_name)
    llm.history = []
    
    request_params = RequestParams(
        maxTokens=8192,
        model=model_name,
        use_history=True,
        max_iterations=10,  # æ”¯æŒå¤šè½®å·¥å…·è°ƒç”¨
        parallel_tool_calls=True,
        temperature=0.3,
    )
    
    response = await llm.generate_str(comprehensive_prompt, request_params)
    
    # 5. ä»å†å²è®°å½•ä¸­æå–å·¥å…·è°ƒç”¨ç»“æœ
    tool_references = extract_tool_call_references(llm.history)
    
    return tool_references
```

### 4. LLMç”Ÿæˆå·¥å…·

**é€šç”¨LLMè°ƒç”¨å°è£…**:

```python
async def _generate_with_llm(
    self,
    state: AgentState,
    prompt: str,
    temperature: float = 0.7,
    max_tokens: int = 4096,
    use_history: bool = True,
    enable_tool_calls: bool = True
) -> str:
    """ä½¿ç”¨LLMç”Ÿæˆæ–‡æœ¬ï¼ˆæ”¯æŒå·¥å…·è°ƒç”¨ï¼‰"""
    
    # 1. ç¡®ä¿MCPä¼šè¯å·²åˆå§‹åŒ–
    await self._ensure_mcp_session(state)
    
    # 2. åˆå§‹åŒ–å†å²è®°å½•
    if not hasattr(self._llm, 'history') or not self._llm.history:
        self._llm.history = []
    
    # 3. é…ç½®è¯·æ±‚å‚æ•°
    request_params = RequestParams(
        maxTokens=max_tokens,
        model=model_name,
        use_history=use_history,
        max_iterations=10 if enable_tool_calls else 1,
        parallel_tool_calls=enable_tool_calls,
        temperature=temperature,
    )
    
    # 4. è°ƒç”¨ LLM ç”Ÿæˆ
    response = await self._llm.generate_str(prompt, request_params)
    
    return response if response else ""
```

---

## è®¾è®¡äº®ç‚¹ä¸åˆ›æ–°

### 1. ğŸ¯ é¢†åŸŸä¸“å®¶åŒ–è®¾è®¡

**åˆ›æ–°ç‚¹**: æ¯ä¸ªæ™ºèƒ½ä½“éƒ½æ˜¯ç‰¹å®šé¢†åŸŸçš„ä¸“å®¶ï¼Œè€Œéé€šç”¨åŠ©æ‰‹

**ä¼˜åŠ¿**:
- ä¸“ä¸šæ·±åº¦å¼º
- æç¤ºè¯ç²¾å‡†
- çŸ¥è¯†åº“ä¸“å±
- å·¥å…·é›†ä¼˜åŒ–

### 2. ğŸ§  æ€ç»´é“¾å¯è§†åŒ–

**åˆ›æ–°ç‚¹**: å®æ—¶å±•ç¤ºæ™ºèƒ½ä½“çš„æ€è€ƒè¿‡ç¨‹

**ä¼˜åŠ¿**:
- å¢å¼ºå¯è§£é‡Šæ€§
- æå‡ç”¨æˆ·ä¿¡ä»»
- ä¾¿äºè°ƒè¯•ä¼˜åŒ–
- æ•™è‚²ä»·å€¼é«˜

### 3. ğŸ”§ å·¥å…·è°ƒç”¨æ··åˆç­–ç•¥

**åˆ›æ–°ç‚¹**: ç›´æ¥è°ƒç”¨Service + MCPå·¥å…·è°ƒç”¨æ··åˆä½¿ç”¨

**ç­–ç•¥**:
- **çŸ¥è¯†æ£€ç´¢**: ç›´æ¥è°ƒç”¨Service (æ€§èƒ½ä¼˜å…ˆ)
- **ç½‘ç»œæœç´¢**: MCPå·¥å…·è°ƒç”¨ (çµæ´»æ€§ä¼˜å…ˆ)
- **LLMç”Ÿæˆ**: MCPå·¥å…·è°ƒç”¨ (èƒ½åŠ›ä¼˜å…ˆ)

**ä¼˜åŠ¿**:
- æ€§èƒ½ä¼˜åŒ–
- æˆæœ¬é™ä½
- å¯é æ€§æå‡

### 4. ğŸ“Š ç»“æ„åŒ–æ•°æ®æå–

**åˆ›æ–°ç‚¹**: LLMç”Ÿæˆè‡ªç„¶è¯­è¨€ + ç»“æ„åŒ–æ•°æ®

**ç¤ºä¾‹**: å›¾è°±éå†
```
è¾“å‡º:
[DESCRIPTION]
æ‰¾åˆ°äº†ä»1å·ä¸»å˜åˆ°10kVæ¯çº¿çš„ä¾›ç”µè·¯å¾„...

[GRAPH_DATA]
{
  "nodes": [...],
  "edges": [...]
}
```

**ä¼˜åŠ¿**:
- è‡ªç„¶è¯­è¨€è§£é‡Š (ç”¨æˆ·å‹å¥½)
- ç»“æ„åŒ–æ•°æ® (å‰ç«¯å¯è§†åŒ–)
- åŒé‡éªŒè¯ (æå‡å‡†ç¡®æ€§)

### 5. ğŸ”„ ä¸¤é˜¶æ®µæ„å›¾è¯†åˆ«

**åˆ›æ–°ç‚¹**: LLMæ„å›¾è¯†åˆ« + è§„åˆ™å›é€€

**æµç¨‹**:
```
ç”¨æˆ·æŸ¥è¯¢
    â†“
å°è¯•LLMæ„å›¾è¯†åˆ« (temperature=0.1)
    â†“
æˆåŠŸ? â”€Yesâ†’ è¿”å›ç»“æ„åŒ–æ„å›¾
    â†“
   No
    â†“
å›é€€åˆ°å…³é”®è¯åŒ¹é…è§„åˆ™
    â†“
è¿”å›ç»“æ„åŒ–æ„å›¾
```

**ä¼˜åŠ¿**:
- æ™ºèƒ½ä¼˜å…ˆ (ç²¾å‡†åº¦é«˜)
- è§„åˆ™ä¿åº• (å¯é æ€§å¼º)
- æ ¼å¼ç»Ÿä¸€ (æ˜“äºå¤„ç†)

### 6. ğŸ¨ æ¨¡æ¿æ¸²æŸ“ç³»ç»Ÿ

**åˆ›æ–°ç‚¹**: Jinja2æ¨¡æ¿ + å‚è€ƒæ–‡æ¡£å­¦ä¹ 

**åŠŸèƒ½**:
1. **æ¨¡æ¿åº“**: é¢„å®šä¹‰çš„æ–‡ä»¶æ¨¡æ¿ (æ“ä½œç¥¨ã€å·¥ä½œç¥¨ç­‰)
2. **å‚è€ƒå­¦ä¹ **: ä»å‚è€ƒæ–‡æ¡£ä¸­æå–æ¨¡æ¿
3. **åŠ¨æ€æ¸²æŸ“**: ä½¿ç”¨Jinja2æ¸²æŸ“æœ€ç»ˆè¾“å‡º

**ç¤ºä¾‹**:
```python
# 1. æ·»åŠ å‚è€ƒæ–‡æ¡£
await agent.add_reference_document(state, doc_content, "æ“ä½œç¥¨ç¤ºä¾‹")

# 2. æå–æ¨¡æ¿
template = await agent.extract_template_from_reference(state)

# 3. æ¸²æŸ“è¾“å‡º
rendered = await agent.render_with_template(
    state=state,
    template_name="operation_ticket.md",
    context={"ticket_no": "OT-2024-001", ...}
)
```

### 7. ğŸš€ åä½œç¼–æ’æœºåˆ¶

**åˆ›æ–°ç‚¹**: å€¼ç­é•¿ (Supervisor) ä¸­å¤®åè°ƒ + ä¸“å®¶å›¢é˜Ÿ

**åä½œæ¨¡å¼**:
- **å¹¶è¡Œæ¨¡å¼**: ç´§æ€¥ä»»åŠ¡ï¼Œå¤šä¸“å®¶åŒæ—¶æ‰§è¡Œ
- **ä¸²è¡Œæ¨¡å¼**: å¸¸è§„ä»»åŠ¡ï¼Œä¸“å®¶ä¾æ¬¡æ‰§è¡Œ

**ä»»åŠ¡åˆ†å‘**:
```python
# 1. ä»»åŠ¡åˆ†æ (LLMæ„å›¾è¯†åˆ«)
task_analysis = await supervisor._analyze_task(state, query)

# 2. ç¡®å®šåä½œæ¨¡å¼
mode = CollaborationMode.PARALLEL if urgent else CollaborationMode.SEQUENTIAL

# 3. æ‰§è¡Œåä½œ
result = await agent_orchestrator.execute_collaboration(
    task=query,
    task_type=task_type,
    mode=mode
)
```

### 8. ğŸ’¾ çŠ¶æ€ç®¡ç†ä¸å…±äº«é»‘æ¿

**åˆ›æ–°ç‚¹**: Blackboard Pattern (å…±äº«é»‘æ¿æ¨¡å¼)

```python
class AgentState(BaseModel):
    session_id: str
    current_plan: Optional[TaskPlan] = None
    memory: List[AgentMessage] = []
    thinking_stream: List[AgentThinkingStep] = []
    
    # å…±äº«é»‘æ¿: å­˜æ”¾å„ä¸ªä¸“å®¶çš„äº§å‡ºç‰©
    shared_context: Dict[str, Any] = {}
```

**ç”¨é€”**:
- ä¸“å®¶é—´æ•°æ®å…±äº«
- ä¸­é—´ç»“æœç¼“å­˜
- ä¸Šä¸‹æ–‡ä¼ é€’

### 9. ğŸ” å¤šç»´åº¦æ£€ç´¢ç­–ç•¥

**åˆ›æ–°ç‚¹**: å‘é‡ + å›¾è°± + å…¨æ–‡ + æ‘˜è¦ æ··åˆæ£€ç´¢

```python
search_request = view_models.SearchRequest(
    query=query,
    rerank=True,  # é‡æ’åº
    vector_search=view_models.VectorSearchParams(topk=top_k, similarity=0.2),
    fulltext_search=view_models.FulltextSearchParams(topk=top_k),
    graph_search=view_models.GraphSearchParams(topk=top_k),
    summary_search=view_models.SummarySearchParams(topk=top_k, similarity=0.2),
)
```

**ä¼˜åŠ¿**:
- å¬å›ç‡é«˜
- ç²¾å‡†åº¦å¼º
- è¦†ç›–é¢å¹¿

### 10. ğŸ›¡ï¸ å¤šå±‚å›é€€æœºåˆ¶

**åˆ›æ–°ç‚¹**: æ°¸è¿œä¸è®©ç”¨æˆ·çœ‹åˆ°ç©ºç™½æˆ–é”™è¯¯

**å›é€€å±‚æ¬¡**:
1. **LLMç”Ÿæˆå¤±è´¥** â†’ ä½¿ç”¨é»˜è®¤æ¨¡æ¿
2. **çŸ¥è¯†åº“æ£€ç´¢å¤±è´¥** â†’ ä½¿ç”¨Mockæ•°æ®
3. **æ¨¡æ¿æ¸²æŸ“å¤±è´¥** â†’ ä½¿ç”¨æ ¼å¼åŒ–è¾“å‡º
4. **æ„å›¾è¯†åˆ«å¤±è´¥** â†’ ä½¿ç”¨å…³é”®è¯åŒ¹é…

**ç¤ºä¾‹**:
```python
try:
    # å°è¯•LLMç”Ÿæˆ
    deduction_data = await self._generate_with_llm(...)
except Exception as e:
    # å›é€€åˆ°é»˜è®¤æ¨¡æ¿
    deduction_data = self._create_accident_deduction(equipment, scenario)
```

---

## æ€»ç»“

### æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. **é¢†åŸŸä¸“å®¶åŒ–**: æ¯ä¸ªæ™ºèƒ½ä½“ä¸“æ³¨ç‰¹å®šé¢†åŸŸ
2. **æ¨¡æ¿æ–¹æ³•**: ç»Ÿä¸€æµç¨‹ï¼Œçµæ´»æ‰©å±•
3. **æ€ç»´é“¾å¯è§†åŒ–**: å¢å¼ºå¯è§£é‡Šæ€§å’Œä¿¡ä»»åº¦
4. **å·¥å…·è°ƒç”¨æ··åˆ**: æ€§èƒ½ä¸çµæ´»æ€§å¹³è¡¡
5. **ç»“æ„åŒ–è¾“å‡º**: è‡ªç„¶è¯­è¨€ + ç»“æ„åŒ–æ•°æ®
6. **å¤šå±‚å›é€€**: æ°¸è¿œæä¾›æœ‰ä»·å€¼çš„è¾“å‡º
7. **åä½œç¼–æ’**: ä¸­å¤®åè°ƒ + ä¸“å®¶å›¢é˜Ÿ
8. **çŠ¶æ€å…±äº«**: é»‘æ¿æ¨¡å¼æ”¯æŒåä½œ

### æŠ€æœ¯æ ˆ

- **æ¡†æ¶**: FastAPI + WebSocket
- **LLMé›†æˆ**: MCP (Model Context Protocol)
- **æ£€ç´¢**: å‘é‡ + å›¾è°± + å…¨æ–‡ + æ‘˜è¦æ··åˆ
- **æ¨¡æ¿**: Jinja2
- **çŠ¶æ€ç®¡ç†**: Pydantic BaseModel
- **å¼‚æ­¥**: asyncio

### è®¾è®¡å“²å­¦

> "è®©æ¯ä¸ªæ™ºèƒ½ä½“æˆä¸ºé¢†åŸŸä¸“å®¶ï¼Œé€šè¿‡åä½œè§£å†³å¤æ‚é—®é¢˜ï¼Œç”¨æ€ç»´é“¾å¢å¼ºå¯è§£é‡Šæ€§ï¼Œç”¨å›é€€æœºåˆ¶ä¿è¯å¯é æ€§ã€‚"

è¿™å¥—æ™ºèƒ½ä½“ç³»ç»Ÿçš„è®¾è®¡å……åˆ†ä½“ç°äº†**ä¸“ä¸šåŒ–ã€å¯è§†åŒ–ã€å¯é æ€§ã€å¯æ‰©å±•æ€§**çš„æ ¸å¿ƒä»·å€¼è§‚ï¼Œä¸ºå˜ç”µç«™æ™ºèƒ½è¿ç»´æä¾›äº†å¼ºå¤§çš„AIæ”¯æŒã€‚
